#include <unordered_map>
#include <map>
#include <unordered_set>
#include <set>
#include <string>
#include <sstream>
#include <stack>
#include <vector>
#include <iostream>
#include <array>
#include <algorithm>
#include <functional>
#include <utility>
#include <random>
#include <fstream>
#include <deque>
#include <mmsystem.h>
#include <numeric>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <initializer_list>
#include <any>
#include <omp.h>
#include <stdarg.h>
#include <queue>
#include <optional>
#include <ctime>
#include <cmath>
#include <cstddef>
#include <cctype>
#include <cstdint>
#include <cstdio>
#include <type_traits>

using namespace std;
using namespace chrono;
using namespace chrono_literals;

///---------------------------------------------------------------------------------
///--- Shorthands ---

using Duration = steady_clock::duration;

Duration Time_Now(){ return steady_clock::now().time_since_epoch(); }

template <typename K>
K Clamp(K i, K upper, K lower){ i > upper ? upper : (i < lower ? lower : i); }

///---------------------------------------------------------------------------------
///--- Hashings ---

template<typename K> struct least_first { bool operator()(const K& l, const K& r) const { return l < r; } };
template<typename K> struct least_last { bool operator()(const K& l, const K& r) const { return l > r; } };

namespace std {
    template <typename K, size_t N>
    struct hash<array<K, N>> { size_t operator()(const array<K, N>& A) const { size_t h; for(const K& e : A) h = hash<K>()(e + h); return h; }};

  	template <typename K>
    struct hash<vector<K>> { size_t operator()(const vector<K>& V) const { size_t h; for(const K& e : V) h = hash<K>()(e + h); return h; }};

    template <typename K>
    struct hash<set<K>> { size_t operator()(const set<K>& S) const { size_t h; for(const K& e : S) h = hash<K>()(e + h); return h; }};

    template <>
    struct hash<Duration> { size_t operator()(const Duration& d) const noexcept { return hash<Duration::rep>()(d.count()); } };

    template <typename U, typename V>
    struct hash<pair<U, V>> { size_t operator()(const pair<U, V>& P) const { return hash<V>()(P.second) ^ hash<U>()(P.first); }};
}
