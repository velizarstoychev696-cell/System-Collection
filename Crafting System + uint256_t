///---------------------------------------------------------------------------------
///
/// --- Crafting System ---
///
/// Layer 1: Bitmask of the 'presence' of the 'Generic Types'
/// Layer 2 (Ordered) : Grid Arrangement as Key, using 'base k' encoding
/// Layer 2 (Unordered) : Summed & magnified number hash as Key
/// Output: List of Item IDs and their Quantities
///

struct uint256_t { array<uint64_t, 4> Value;
	uint64_t& operator [] (uint8_t i) { return Value[i]; }
	bool operator == (uint256_t& R) { for(size_t i = 0; i < 4; i++) if(Value[i] != R[i]){ return false; } return true; }
	bool operator != (size_t R)  { for(auto& v : Value) if(v == R){ return false; } return true; }
	uint256_t& Set_One (uint8_t P) { Value[P >> 6] |=   1ULL << ((P << 2) >> 2);  return *this; }
	uint256_t& Set_Zero(uint8_t P) { Value[P >> 6] &= ~(1ULL << ((P << 2) >> 2)); return *this; }
	uint8_t Pop_Count() { uint8_t b = 0; for(auto& v : Value) for(size_t j = 0; j < 64; j++) if(v & 1ULL << j) { b++; } return b; }

	operator array<uint64_t, 4>() const { return Value; }
	operator string() const { string result(32, '\0');
		memcpy(&result[0], Value.data(), 32); return result;
	}

	bool operator && (uint256_t R) const { for(size_t i = 0; i < 4; i++) if((Value[i] & R[i]) == 0) { return false; } return true; }
	uint256_t& operator += (uint256_t& R) { for(size_t i = 0; i < 3; i++) { Value[i + 1] += (Value[i] += R[i]) < R[i]; } Value[3] += R[3]; return *this; }
	uint256_t& operator += (uint64_t R) { Value[1] += (Value[0] += R) < R; return *this; }
	uint256_t& operator *= (uint64_t R) { uint64_t carry = 0; for(int i = 0; i < 4; i++) {
			uint64_t al = (uint32_t) Value[i], bl = (uint32_t) R, ah = Value[i] >> 32, bh = R >> 32;
			uint64_t p = al * bl, p1 = al * bh, p2 = ah * bl, m = (p >> 32) + (uint32_t) p1 + (uint32_t) p2;
			uint64_t h = (ah * bh) + (p1 >> 32) + (p2 >> 32) + (m >> 32), l = (m << 32) | (uint32_t) p;
			carry = h + ((Value[i] = l + carry) < l);
		} return *this;
	}
}; namespace std { template <> struct hash<uint256_t> { size_t operator()(const uint256_t& i) const { size_t seed = 69; for(const uint64_t& e : i.Value) hash_combine(seed, e); return seed; }}; }

using Recipe_Storage = unordered_map<uint256_t, unordered_map<uint256_t, vector<Item>>>;

template<uint16_t Slots> struct Station { Recipe_Storage U, O;
	array<Item, Slots> Grid;

	vector<Item> Craft() { size_t j; uint256_t L, Lo, Lu; set<uint32_t> Uniques; hash<uint32_t> h;
		for(auto i: Grid) { Uniques.insert(i.ID); L.Set_One(i.ID >> 24); Lu += h(i.ID) * i.Quantity; }
		for(auto u: Uniques) { uint256_t l; for(auto i: Grid){ (l *= Uniques.size()) += j & (i.ID == u); } Lo += l; }
		if(O.find(L) != O.end() && U.find(L) != U.end()) {
			switch((O[L].find(Lo) != O[L].end()) + ((U[L].find(Lu) != U[L].end()) << 1)) { default: return U[L][Lu];
				case 0: return {}; case 1: return O[L][Lo];
	}	}	}

	void Add_Grid(uint8_t Slot, Item i) { Grid[Slot] = i; Craft(); }
	void Remove_Grid(uint8_t Slot) { Grid[Slot] = Item(); Craft(); }

	void Add_Ordered_Recipe(array<Item, Slots> Input, vector<Item> Output) { size_t j; uint256_t L, Lo; set<uint32_t> Uniques;
		for(auto i: Input) { Uniques.insert(i.ID); L.Set_One(i.ID >> 24); }
		for(auto u: Uniques) { uint256_t l; for(auto i: Input) (l *= Uniques.size()) += j & (i.ID == u); Lo += l; } O[L][Lo] = Output;
	}

	void Add_Unordered_Recipe(array<Item, Slots> Input, vector<Item> Output) { uint256_t L, Lu; hash<uint32_t> h;
		for(auto i: Input) { L.Set_One(i.ID >> 24); Lu += h(i.ID) * i.Quantity; } U[L][Lu] = Output;
	}

	/// Only use the map Keys (Values don't matter for casual use)
	unordered_map<uint256_t, uint8_t> Find_Barely_Craftable(vector<Item> Items) { unordered_map<uint256_t, uint8_t> Result;
		for(auto i : Items) for(auto& m : O) { uint256_t l; if((m.first && (l.Set_One(i.ID >> 24))) != 0) Result[m.first]++; }
		for(auto i : Items) for(auto& m : U) { uint256_t l; if((m.first && (l.Set_One(i.ID >> 24))) != 0) Result[m.first]++; }
		return Result;
	} set<uint256_t> Find_Very_Craftable(vector<Item> Items, uint8_t Tolerance) { set<uint256_t> Result;
		for(auto [k, v] : Find_Barely_Craftable(Items)) if(k.Pop_Count() - v <= Tolerance) Result.insert(k);
		return Result;
	}

	void Record_To_File(const string& path) { ofstream ofs(path, ios::binary);
		Serializer S(ofs); // Basic File Writing
		S.Write(O); S.Write(U);
	} void Load_From_File(const string& path) { ifstream ifs(path, ios::binary);
		Serializer S(ifs); // Basic File Reading
		O = S.Read<Recipe_Storage>(); U = S.Read<Recipe_Storage>();
	}
};
