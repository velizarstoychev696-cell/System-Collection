///---------------------------------------------------------------------------------
///--- Rhythm Game Chart Engine ---

/// Helps ignore the template of Chart when stored in the same container
struct General_Chart { set<int8_t> Ranks;
	array<array<map<int, int>::iterator, 1>, 1> Current;
	array<array<uint16_t, 1>, 1> Hold;
	array<map<int, int>, 1> Notes;

	double Long_Note_Leniency = 0.8;
	uint8_t SO, JO; /// Extra Stair & Jack Offsets

	map<int, uint8_t> Stairs, Jacks;
	map<int, set<uint8_t>> Chords;
	set<int> Mines;

	int8_t Press(const uint8_t Lane, const uint32_t Time, const uint8_t I){ return I; }
	array<int8_t, 1> BotTap(const uint32_t Time, const uint8_t I){ return {}; }
	uint32_t Args(uint8_t i) const { return i; }
};

template<uint8_t Lanes = 4, uint32_t BPS = 32, uint8_t Instances = 1> // How many Keys, How many equidistant Notes per second are allowed, How many times the same chart is played at once
struct Chart : General_Chart { set<int8_t> Ranks; // Note Rankings as beat offset (Latest Note Rank is the first), Negative Ranks are for Mines (Latest Mine Rank is last)
    array<map<int, int>, Lanes> Notes; /// Note Position & Length per Lane, Negative Positions are Mines
	array<array<map<int, int>::iterator, Instances>, Lanes> Current;
	array<array<uint16_t, Instances>, Lanes> Hold;

	/// Score: -2 = Mine, -1 = Ghost Tap (Too Early), 0 = Holding, 1 = Missed Note (Too Late), 2 = Nothing yet;
	/// Score: Rank + 3 = Early/Late Score; (Closer to 0 means better, but -2 through 2 are taken)
    int8_t Press(uint8_t Lane, uint32_t Time, uint8_t I, double Leniency) { int P = Current[Lane][I]->first, G = Time - max(P, -P) - Hold[Lane][I];
    	int8_t Score = 0, C = P < 0 ? *Ranks.begin() : -(*prev(Ranks.end()));
    	bool H = Hold[Lane][I] == ceil(Clamp<double>(Leniency, 1, 0) * Current[Lane][I]->second), B = P < 0, T = G > -C; // Holding?, Bomb?, Too Early/Late?
    	switch((G < C) ^ T ? H * (B + 1) : 3 + T) { case 0: Hold[Lane][I]++; return 0;
			case 1: P++; for(int8_t r : Ranks) { if(max(G, -G) <= r && r >= 0) { Score = r + 3; } else break; } Hold[Lane][I] = 0; return Score;
			case 2: P++; return -2;
			case 3: P++; Press(Lane, Time); return 1; /// Recursion is indeed finite, dummy.
			case 4: return -1;
	}} uint32_t Args(uint8_t i) const { switch(i) { case 0: return Lanes; case 1: return BPS; case 2: return Instances; } }
	// To "Hold" Press() needs to be repeatedly called, but only while Score = 0.

	/// Reads the Chart perfectly. (Can help with the timing of the visuals, and is literally Bot-Play)
	array<int8_t, Lanes> BotTap(uint32_t Time, uint8_t I){ array<int8_t, Lanes> Result; auto& P = Current;
		for(uint8_t l = 0; l < Lanes; l++) if(Time - Hold[l][I] - P[l][I]->first == P[l][I]->second) { P[l][I]++;
			Result[l] = 2; Hold[l][I] = 0;
	} else { Result[l] = 1; Hold[l][I]++; } return Result; }

	void Serialize(Serializer& s) const { s.Write(Ranks); s.Write(Notes); s.Write(Jacks); s.Write(Chords); s.Write(Stairs); s.Write(Mines); }
    void Deserialize(Serializer& s) { Ranks = s.Read<set<int8_t>>();
		Notes = s.Read<array<map<int, int>, Lanes>>();
		Chords = s.Read<map<int, set<uint8_t>>>();
		Stairs = s.Read<map<int, set<uint8_t>>>();
		Jacks  = s.Read<map<int, uint8_t>>();
		Mines  = s.Read<set<int>>();
    }
}; /// Handles a full Rhythm Game Chart, intended for keyboard

template<bool Track_Patterns = true> struct Chart_Engine {
	vector<General_Chart> Charts;

	void Add_Note(size_t Index, uint8_t Lane, int Position, int Length = 0) { auto& GC = Charts.at(Index);
		GC.Notes.at(Lane).emplace(Position, Length);
		if(Track_Patterns) { GC.Chords[Position].insert(Lane);
			for(int8_t s = 1; s <= max(GC.SO, GC.JO) + 1; s++) { if(GC.Stairs[Position] != 0 && GC.Jacks[Position] != 0) break;
				auto& P = { GC.Chords.find(Position - s), GC.Chords.find(Position + s) };
				for(auto& p : P) if(p != GC.Chords.end()) switch((p->second.find(Lane) != p->second.end()) + ((p->second.size() > 0) << 1)) {
					case 1: GC.Jacks[Position] = s <= GC.JO ? s : 0;
					case 2: GC.Stairs[Position] = s <= GC.SO ? s : 0;
					case 3: GC.Stairs[Position] = s <= GC.SO ? s : 0;
			} } if(Position < 0) GC.Mines.insert(Position);
	}	} /// This works well with a Chart Editing GUI

	void Remove_Note(size_t Index, uint8_t Lane, int Position) { auto& GC = Charts.at(Index);
		GC.Notes[Lane].erase(Position);
		GC.Chords[Position].erase(Lane);
		GC.Mines.erase(Position);
		GC.Jacks.erase(Position);
		auto J = GC.Jacks.find(Position)--;
		if(J != GC.Jacks.end()) J->second = 0;
		if(GC.Chords[Position].size()) { GC.Stairs.erase(Position); GC.Chords.erase(Position); }
	}

	void Set_Leniency(size_t Index, double Long, uint8_t Jack, uint8_t Stair) { auto& GC = Charts.at(Index); auto N = GC.Notes;
		GC.Notes = {}; GC.Jacks.clear(); GC.Mines.clear(); GC.Chords.clear(); GC.Stairs.clear();
		for(uint8_t i = 0; i < N.size(); i++) for(auto it = N[i].begin(); it != N[i].end(); it++) Add_Note(Index, i, it->first, it->second);
	}

	void Reset_Progress(size_t Index, uint8_t I){ auto& GC = Charts.at(Index); GC.Hold = {};
		for(uint8_t l = 0; l < GC.Args(0); l++) GC.Current[l][I] = GC.Notes[l].begin();
	}

	void Record_To_File(const string& path) { ofstream ofs(path, ios::binary);
		Serializer S(ofs);
		S.Write(Charts);
	}

	void Load_From_File(const string& path) { ifstream ifs(path, ios::binary);
		Serializer S(ifs);
		Charts = S.Read<vector<General_Chart>>();
	}
};
