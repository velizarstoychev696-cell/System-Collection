///---------------------------------------------------------------------------------
///--- Rhythm Game Chart Engine ---

struct General_Chart { set<int8_t> Ranks;
	array<map<int, int>, 1> Notes;
	array<array<uint16_t, 1>, 1> Hold;
	array<array<map<int, int>::iterator, 1>, 1> Current;
	int8_t Press(const uint8_t Lane, const uint32_t Time, const uint8_t I){ return I; }
	array<int8_t, 1> BotTap(const uint32_t Time, const uint8_t I){ return {}; }
	uint32_t Args(uint8_t i) const { return i; }
	void Serialize(Serializer& s) const {}
    static void Deserialize(Serializer& s) { return ; }
};

template<uint8_t Lanes = 4, uint32_t BPS = 32, uint8_t Instances = 1> // How many Keys, How many equidistant Notes per second are allowed, How many times the same chart is played at once
struct Chart : General_Chart { set<int8_t> Ranks; // Note Rankings as beat offset (Latest Note Rank is the first), Negative Ranks are for Mines (Latest Mine Rank is last)
    array<map<int, int>, Lanes> Notes; /// Note Position & Length per Lane, Negative Positions are Mines
	array<array<map<int, int>::iterator, Instances>, Lanes> Current;
	array<array<uint16_t, Instances>, Lanes> Hold;

	/// Score: -2 = Mine, -1 = Ghost Tap (Too Early), 0 = Holding, 1 = Missed Note (Too Late), 2 = Nothing yet;
	/// Score: Rank + 3 = Early/Late Score; (Closer to 0 means better, but -2 through 2 are taken)
    int8_t Press(uint8_t Lane, uint32_t Time, uint8_t I, float Leniency) { int P = Current[Lane][I]->first, G = Time - max(P, -P) - Hold[Lane][I];
    	int8_t Score = 0, C = P < 0 ? *Ranks.begin() : -(*prev(Ranks.end()));
    	bool H = Hold[Lane][I] == ceil(Leniency * Current[Lane][I]->second), B = P < 0, T = G > -C; // Holding?, Bomb?, Too Early/Late?
    	switch((G < C) ^ T ? H * (B + 1) : 3 + T) { case 0: Hold[Lane][I]++; return 0;
			case 1: P++; for(int8_t r : Ranks) { if(max(G, -G) <= r && r >= 0) { Score = r + 3; } else break; } Hold[Lane][I] = 0; return Score;
			case 2: P++; return -2;
			case 3: P++; Press(Lane, Time); return 1; /// Recursion is indeed finite, dummy.
			case 4: return -1;
	}} uint32_t Args(uint8_t i) const { switch(i){ case 0: return Lanes; case 1: return BPS; case 2: return Instances; } }
	// To "Hold" Press() needs to be repeatedly called, but only while Score = 0.

	/// Reads the Chart perfectly. (Can help with the timing of the visuals, and is literally Bot-Play)
	array<int8_t, Lanes> BotTap(uint32_t Time, uint8_t I){ array<int8_t, Lanes> Result; auto& P = Current;
		for(uint8_t l = 0; l < Lanes; l++) if(Time - Hold[l][I] - P[l][I]->first == P[l][I]->second) { P[l][I]++;
			Result[l] = 2; Hold[l][I] = 0;
	} else { Result[l] = 1; Hold[l][I]++; } return Result; }

	void Serialize(Serializer& s) const { s.Write(Ranks); s.Write(Notes); }
    void Deserialize(Serializer& s) { Ranks = s.Read<set<int8_t>>(); Notes = s.Read<array<map<int, int>, Lanes>>(); }
};

template<bool Track_Chords = true> struct Chart_Engine { double Leniency = 0.8; /// General Precision Leniency
	vector<map<int, vector<uint8_t>>> Chords;
	vector<General_Chart> Charts;

	General_Chart& Add_Note(size_t Index, uint8_t Lane, int Position, int Length = 0) { General_Chart GC = Charts.at(Index);
		if(Lane < GC.Args(0)) { GC.Notes[Lane].emplace(Position, Length); Chords.resize(Charts.size());
			if(Track_Chords) Chords.at(Index)[Position].push_back(Lane);
	} return GC; }

	void Reset_Progress(size_t Index, uint8_t I){ General_Chart GC = Charts.at(Index); GC.Hold = {};
		for(uint8_t l = 0; l < GC.Args(0); l++) GC.Current[l][I] = GC.Notes[l].begin();
	}
	
	void Record_To_File(const string& path) { ofstream ofs(path, ios::binary);
		Serializer S(ofs);
		S.Write(Charts);
	}
	
	void Load_From_File(const string& path) { ifstream ifs(path, ios::binary);
		Serializer S(ifs);
		Charts = S.Read<vector<General_Chart>>();
	}
};
